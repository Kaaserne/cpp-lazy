#pragma once

#ifndef LZ_GENERATE_WHILE_HPP
#    define LZ_GENERATE_WHILE_HPP

#    include "detail/BasicIteratorView.hpp"
#    include "detail/GenerateWhileIterator.hpp"

namespace lz {

LZ_MODULE_EXPORT_SCOPE_BEGIN

template<class GeneratorFunc, class... Args>
class GenerateWhile final : public internal::BasicIteratorView<internal::GenerateWhileIterator<GeneratorFunc, Args...>> {
public:
    using iterator = internal::GenerateWhileIterator<GeneratorFunc, Args...>;
    using const_iterator = iterator;
    using value_type = typename iterator::value_type;

    constexpr GenerateWhile(GeneratorFunc func, std::tuple<Args...> tuple) :
        internal::BasicIteratorView<iterator>(iterator(func, tuple, false), iterator(func, tuple, true)) {
    }

    constexpr GenerateWhile() = default;
};

/**
 * @addtogroup ItFns
 * @{
 */

/**
 * @brief Returns a view to a generate iterator.
 * @details This object can be used to generate any amount of values while it returns `true` (or something that is convertible to
 * `true`), generated by the `generatorFunc` function. The generator function must return an object where `std::get<0>` must
 * return a bool like object (while it returns `true`/something convertible to `true`, it gets executed, if `false`/something that
 * is convertible to `false`, it doesn't). The type that is returned by `std::get<1>` can be any type. Typically this is a
 * `std::pair<bool, T>`, but can also be a std::tuple<bool, T> or any other type that is compatible with std::get Example:
 * ```cpp
 * auto vector = lz::generateWhile([](int& i) { return std::make_pair(i == 4, i++); }, 0).toVector();
 * // vector yields: { 0, 1, 2, 3 }
 * ```
 * @param generatorFunc The function to execute any amount of times as long as it returns `{true/boolean like value,
 * <someValue>}`.
 * @param args Args to pass (they are copied) to the function @p generatorFunc. Arguments of the @p generatorFunc can be accessed
 * by (const) reference as seen in the example above
 * @return A generator iterator view object.
 */
template<class GeneratorFunc, class... Args>
LZ_NODISCARD constexpr GenerateWhile<internal::Decay<GeneratorFunc>, internal::Decay<Args>...>
generateWhile(GeneratorFunc&& generatorFunc, Args&&... args) {
    using PairLike = decltype(generatorFunc(std::declval<typename std::add_lvalue_reference<Args>::type>()...));
    using PairFirst = decltype(std::get<0>(std::declval<PairLike>()));

    static_assert(std::is_convertible<internal::Decay<PairFirst>, bool>::value,
                  "Function must return a std::get compatible object, where std::get<0> returns a bool like object.");
    return { std::forward<GeneratorFunc>(generatorFunc), std::make_tuple(std::forward<Args>(args)...) };
}

// End of group
/**
 * @}
 */

LZ_MODULE_EXPORT_SCOPE_END

} // namespace lz

#endif