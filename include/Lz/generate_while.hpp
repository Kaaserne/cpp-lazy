// #pragma once

// #ifndef LZ_GENERATE_WHILE_HPP
// #define LZ_GENERATE_WHILE_HPP

// #include <Lz/basic_iterable.hpp>
// #include <Lz/detail/iterators/generate_while.hpp>

// namespace lz {

// LZ_MODULE_EXPORT_SCOPE_BEGIN

// template<class GeneratorFunc>
// class generate_while_iterable final
//     : public detail::basic_iterable<detail::generate_while_iterator<GeneratorFunc>, default_sentinel> {
// public:
//     using iterator = detail::generate_while_iterator<GeneratorFunc>;
//     using const_iterator = iterator;
//     using value_type = typename iterator::value_type;

//     LZ_CONSTEXPR_CXX_14 generate_while_iterable(GeneratorFunc func) :
//         detail::basic_iterable<iterator, default_sentinel>(iterator(std::move(func))) {
//     }

//     constexpr generate_while_iterable() = default;
// };

// /**
//  * @addtogroup ItFns
//  * @{
//  */

// // TODO remove args from generate_while and generate?

// /**
//  * This object can be used to generate any amount of values while it returns `true` (or something that is convertible to
//  * `true`), generated by the `generator_func` function. The generator function must return a std::pair like object where
//  * `object::first` must return a bool like object (while it returns `true`/something convertible to `true`, it gets executed,
//  if
//  * `false`/something that is convertible to `false`, it doesn't). The type that is returned by `object::second` can be any
//  type.
//  * Example:
//  * ```cpp
//  * auto vector = lz::generate_while([i = 0]() mutable { return std::make_pair(i == 4, i++); }).to_vector();
//  * // vector yields: { 0, 1, 2, 3 }
//  * ```
//  * @param generator_func The function to execute any amount of times as long as it returns a pair of `{true/boolean like value,
//  * <some_value>}`.
//  * @return A generator iterator view object.
//  */
// template<class GeneratorFunc, class... Args>
// LZ_NODISCARD LZ_CONSTEXPR_CXX_14 generate_while_iterable<detail::decay_t<GeneratorFunc>>
// generate_while(GeneratorFunc&& generator_func, Args&&... args) {
//     using pair = decltype(generator_func(args...));
//     using pair_first = decltype(std::get<0>(std::declval<pair>()));

//     static_assert(std::is_convertible<detail::decay_t<pair_first>, bool>::value,
//                   "Function must return a std::pair compatible object (i.e. object::first, object::second), where object::first
//                   " "returns a bool like object.");
//     return { std::forward<GeneratorFunc>(generator_func) };
// }

// // End of group
// /**
//  * @}
//  */

// LZ_MODULE_EXPORT_SCOPE_END

// } // namespace lz

// #endif